diff --git a/src/JobDbRepository.ts b/src/JobDbRepository.ts
index 3f216c7..2fe6265 100644
--- a/src/JobDbRepository.ts
+++ b/src/JobDbRepository.ts
@@ -106,16 +106,16 @@ export class JobDbRepository {
 
 		// Update / options for the MongoDB query
 		const update: UpdateFilter<IJobParameters> = { $set: { lockedAt: new Date() } };
-		const options: FindOneAndUpdateOptions = {
-			returnDocument: 'after',
-			sort: this.connectOptions.sort
-		};
 
 		// Lock the job in MongoDB!
 		const resp = await this.collection.findOneAndUpdate(
 			criteria as Filter<IJobParameters>,
 			update,
-			options
+			{
+				includeResultMetadata: true,
+				returnDocument: 'after',
+				sort: this.connectOptions.sort,
+			}
 		);
 
 		return resp?.value || undefined;
@@ -131,41 +131,37 @@ export class JobDbRepository {
 		 * Query used to find job to run
 		 */
 		const JOB_PROCESS_WHERE_QUERY: Filter<IJobParameters /* Omit<IJobParameters, 'lockedAt'> & { lockedAt?: Date | null } */> =
-			{
-				name: jobName,
-				disabled: { $ne: true },
-				$or: [
-					{
-						lockedAt: { $eq: null as any },
-						nextRunAt: { $lte: nextScanAt }
-					},
-					{
-						lockedAt: { $lte: lockDeadline }
-					}
-				]
-			};
+		{
+			name: jobName,
+			disabled: { $ne: true },
+			$or: [
+				{
+					lockedAt: { $eq: null as any },
+					nextRunAt: { $lte: nextScanAt }
+				},
+				{
+					lockedAt: { $lte: lockDeadline }
+				}
+			]
+		};
 
 		/**
 		 * Query used to set a job as locked
 		 */
 		const JOB_PROCESS_SET_QUERY: UpdateFilter<IJobParameters> = { $set: { lockedAt: now } };
 
-		/**
-		 * Query used to affect what gets returned
-		 */
-		const JOB_RETURN_QUERY: FindOneAndUpdateOptions = {
-			returnDocument: 'after',
-			sort: this.connectOptions.sort
-		};
-
 		// Find ONE and ONLY ONE job and set the 'lockedAt' time so that job begins to be processed
 		const result = await this.collection.findOneAndUpdate(
 			JOB_PROCESS_WHERE_QUERY,
 			JOB_PROCESS_SET_QUERY,
-			JOB_RETURN_QUERY
+			{
+				includeResultMetadata: true,
+				returnDocument: 'after',
+				sort: this.connectOptions.sort
+			}
 		);
 
-		return result.value || undefined;
+		return result?.value || undefined;
 	}
 
 	async connect(): Promise<void> {
@@ -177,10 +173,9 @@ export class JobDbRepository {
 		this.collection = db.collection(collection);
 		if (log.enabled) {
 			log(
-				`connected with collection: ${collection}, collection size: ${
-					typeof this.collection.estimatedDocumentCount === 'function'
-						? await this.collection.estimatedDocumentCount()
-						: '?'
+				`connected with collection: ${collection}, collection size: ${typeof this.collection.estimatedDocumentCount === 'function'
+					? await this.collection.estimatedDocumentCount()
+					: '?'
 				}`
 			);
 		}
@@ -313,9 +308,9 @@ export class JobDbRepository {
 				const result = await this.collection.findOneAndUpdate(
 					{ _id: id, name: props.name },
 					update,
-					{ returnDocument: 'after' }
+					{ includeResultMetadata: true, returnDocument: 'after' }
 				);
-				return this.processDbResult(job, result.value as IJobParameters<DATA>);
+				return this.processDbResult(job, result?.value as IJobParameters<DATA>);
 			}
 
 			if (props.type === 'single') {
@@ -351,18 +346,19 @@ export class JobDbRepository {
 					},
 					update,
 					{
+						includeResultMetadata: true,
 						upsert: true,
 						returnDocument: 'after'
 					}
 				);
 				log(
 					`findOneAndUpdate(${props.name}) with type "single" ${
-						result.lastErrorObject?.updatedExisting
-							? 'updated existing entry'
-							: 'inserted new entry'
+						result?.lastErrorObject?.updatedExisting
+						? 'updated existing entry'
+						: 'inserted new entry'
 					}`
 				);
-				return this.processDbResult(job, result.value as IJobParameters<DATA>);
+				return this.processDbResult(job, result?.value as IJobParameters<DATA>);
 			}
 
 			if (job.attrs.unique) {
@@ -376,10 +372,11 @@ export class JobDbRepository {
 				// Use the 'unique' query object to find an existing job or create a new one
 				log('calling findOneAndUpdate() with unique object as query: \n%O', query);
 				const result = await this.collection.findOneAndUpdate(query as IJobParameters, update, {
+					includeResultMetadata: true,
 					upsert: true,
 					returnDocument: 'after'
 				});
-				return this.processDbResult(job, result.value as IJobParameters<DATA>);
+				return this.processDbResult(job, result?.value as IJobParameters<DATA>);
 			}
 
 			// If all else fails, the job does not exist yet so we just insert it into MongoDB
